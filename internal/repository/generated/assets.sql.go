// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: assets.sql

package repository

import (
	"context"

	"github.com/google/uuid"
)

const deleteAsset = `-- name: DeleteAsset :exec
DELETE FROM assets
WHERE id = $1
`

func (q *Queries) DeleteAsset(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAsset, id)
	return err
}

const getAllAssetsPaginated = `-- name: GetAllAssetsPaginated :many
SELECT id, file_name, content_type, e_tag, container_name, uri, size, metadata, is_public, published, updated_at, created_at
FROM assets
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type GetAllAssetsPaginatedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllAssetsPaginated(ctx context.Context, arg GetAllAssetsPaginatedParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getAllAssetsPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.ID,
			&i.FileName,
			&i.ContentType,
			&i.ETag,
			&i.ContainerName,
			&i.Uri,
			&i.Size,
			&i.Metadata,
			&i.IsPublic,
			&i.Published,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssetByFileName = `-- name: GetAssetByFileName :one
SELECT id, file_name, content_type, e_tag, container_name, uri, size, metadata, is_public, published, updated_at, created_at
FROM assets
WHERE file_name = $1
`

func (q *Queries) GetAssetByFileName(ctx context.Context, fileName string) (Asset, error) {
	row := q.db.QueryRow(ctx, getAssetByFileName, fileName)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.FileName,
		&i.ContentType,
		&i.ETag,
		&i.ContainerName,
		&i.Uri,
		&i.Size,
		&i.Metadata,
		&i.IsPublic,
		&i.Published,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getAssetByID = `-- name: GetAssetByID :one
SELECT id, file_name, content_type, e_tag, container_name, uri, size, metadata, is_public, published, updated_at, created_at
FROM assets
WHERE id = $1
`

func (q *Queries) GetAssetByID(ctx context.Context, id uuid.UUID) (Asset, error) {
	row := q.db.QueryRow(ctx, getAssetByID, id)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.FileName,
		&i.ContentType,
		&i.ETag,
		&i.ContainerName,
		&i.Uri,
		&i.Size,
		&i.Metadata,
		&i.IsPublic,
		&i.Published,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getAssetsCount = `-- name: GetAssetsCount :one
SELECT COUNT(*) AS total_count
FROM assets
`

func (q *Queries) GetAssetsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getAssetsCount)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const getPublicAssetsPaginated = `-- name: GetPublicAssetsPaginated :many
SELECT id, file_name, content_type, e_tag, container_name, uri, size, metadata, is_public, published, updated_at, created_at
FROM assets
WHERE is_public = true
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type GetPublicAssetsPaginatedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetPublicAssetsPaginated(ctx context.Context, arg GetPublicAssetsPaginatedParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getPublicAssetsPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.ID,
			&i.FileName,
			&i.ContentType,
			&i.ETag,
			&i.ContainerName,
			&i.Uri,
			&i.Size,
			&i.Metadata,
			&i.IsPublic,
			&i.Published,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertAsset = `-- name: InsertAsset :one
INSERT INTO assets (file_name, content_type, e_tag, container_name, uri, size, metadata, is_public, published, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, now(), now())
RETURNING id, file_name, content_type, e_tag, container_name, uri, size, metadata, is_public, published, updated_at, created_at
`

type InsertAssetParams struct {
	FileName      string `json:"file_name"`
	ContentType   string `json:"content_type"`
	ETag          string `json:"e_tag"`
	ContainerName string `json:"container_name"`
	Uri           string `json:"uri"`
	Size          int32  `json:"size"`
	Metadata      []byte `json:"metadata"`
	IsPublic      bool   `json:"is_public"`
	Published     bool   `json:"published"`
}

func (q *Queries) InsertAsset(ctx context.Context, arg InsertAssetParams) (Asset, error) {
	row := q.db.QueryRow(ctx, insertAsset,
		arg.FileName,
		arg.ContentType,
		arg.ETag,
		arg.ContainerName,
		arg.Uri,
		arg.Size,
		arg.Metadata,
		arg.IsPublic,
		arg.Published,
	)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.FileName,
		&i.ContentType,
		&i.ETag,
		&i.ContainerName,
		&i.Uri,
		&i.Size,
		&i.Metadata,
		&i.IsPublic,
		&i.Published,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateAsset = `-- name: UpdateAsset :one
UPDATE assets
SET file_name = COALESCE($2, file_name),
    content_type = COALESCE($3, content_type),
    e_tag = COALESCE($4, e_tag),
    container_name = COALESCE($5, container_name),
    uri = COALESCE($6, uri),
    size = COALESCE($7, size),
    metadata = COALESCE($8, metadata),
    is_public = COALESCE($9, is_public),
    published = COALESCE($10, published),
    updated_at = now()
WHERE id = $1
RETURNING id, file_name, content_type, e_tag, container_name, uri, size, metadata, is_public, published, updated_at, created_at
`

type UpdateAssetParams struct {
	ID            uuid.UUID `json:"id"`
	FileName      string    `json:"file_name"`
	ContentType   string    `json:"content_type"`
	ETag          string    `json:"e_tag"`
	ContainerName string    `json:"container_name"`
	Uri           string    `json:"uri"`
	Size          int32     `json:"size"`
	Metadata      []byte    `json:"metadata"`
	IsPublic      bool      `json:"is_public"`
	Published     bool      `json:"published"`
}

func (q *Queries) UpdateAsset(ctx context.Context, arg UpdateAssetParams) (Asset, error) {
	row := q.db.QueryRow(ctx, updateAsset,
		arg.ID,
		arg.FileName,
		arg.ContentType,
		arg.ETag,
		arg.ContainerName,
		arg.Uri,
		arg.Size,
		arg.Metadata,
		arg.IsPublic,
		arg.Published,
	)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.FileName,
		&i.ContentType,
		&i.ETag,
		&i.ContainerName,
		&i.Uri,
		&i.Size,
		&i.Metadata,
		&i.IsPublic,
		&i.Published,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
